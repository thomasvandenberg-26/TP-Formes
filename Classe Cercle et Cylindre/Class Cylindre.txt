public class clsCylindre : clsCercle
{
    public clsCylindre(Point depart,Color color,  string ANom, ushort ARayon, ushort AProfondeur)
    : base (depart, color, ANom, ARayon)
    {
        profondeur = AProfondeur;
    }

    public ushort _profondeur;

    public ushort profondeur
    {
        get { return _profondeur; }
        set { _profondeur = value; }
    }


    internal override void Dessine()
    {

        Console.WriteLine($"--- clsCylindre.Dessine(X={depart.X} Y={depart.Y} Color={Couleur} R={Rayon} P={profondeur}\"{Nom}\")");
    }

    internal override void Zoom(float ACoeffX, float ACoeffY = 1)
    {
        // Expansion Largeur & Hauteur

        Console.WriteLine($"clsCercle.Zoom(CoeffX={ACoeffX} CoeffX={ACoeffY} \"{Nom}\")");



        if (ACoeffX < 0.0f)

            ACoeffX = 1.0f; // Coeff négatif non accepté


        if (ACoeffX < 0.0f)

            ACoeffX = 1.0f; // Coeff négatif non accepté
        LogEvents.Instance.PushEvent(new Event(EventType.Information, "Coefficient de zoom négatif pour X. Valeur par défaut 1.0 utilisée.")); ;

        try
        {

            profondeur = (ushort)(profondeur * ACoeffX); // Calcul nouvelle Rayon

        }
        catch(OverflowException oe)
        {
            LogEvents.Instance.PushEvent(new Event(EventType.Alarme, $"{oe.Message} - {Nom}"));
            profondeur = ushort.MaxValue; // Définit à la valeur maximale en cas de débordement
        }


        Dessine();
    }

    public override string ToString()

    {
        
        return $"Cercle \"{Nom}\": X={depart.X} Y={depart.Y} Color={Couleur} R={Rayon} P={profondeur}";

    }

}
